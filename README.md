# VeeamTest

В папке Build находится исполняемый файл. 
При запуске из консоли без параметров выводится список параметров командной строки.

## Параметры: 

*  -c, --compress      Команда для разбиения файла на блоки
*  -d, --decompress    Комманда для востановления исходного файла
*  -i, --input         Файл с входными данными.
*  -o, --output        Файл с выходными данными.
*  -s, --size          Размер блока в байтах при разбиенни файла. (Значение по умолчанию: 1048576).
*  --hash              Тип хэш функиции. [MD5|SHA256] (Значение по умолчанию: MD5) 
*  --help              Вывод подсказки.

Возможна остановка программы по нажатию Ctrl-C.

## Сигнатура генерируемого файла:
Для файла генерируется заголовок, после заголовка идут блоки, на которые разбит исходный файл.

## Структура заголовка:
* BlockSize - размер исходного блока (последний блок может быть меньше BlockSize)
* BlocksCount - количество блоков
* HashType - тип хэш функции
* HashSize - размер хэша
Размер заголовка в бинарном виде составляем 13 байт.

## Структура блока
* BlockSize - (первые 4 байта блока) размер тела блока
* Id - номер блока
* OriginBlockSize - размер исходного блока
* Hash - хэш блока
* Data - данные блока

## Восстановление исходного файла
Так как генерируемый файл может содержать блоки не в том порядке в котором они читались из исходного файла, то при восстановлении исходного файла каждый считанный блок пишется в поток со смещением равным block.Id * header.BlockSize.
Таким образом для каждого блока задаётся своё смещение. 
При восстановлении исходного файла для данных вычисляются заного хэши и сравниваются с теми, которые есть в сгенерированном файле.

Для компресии и декомпресии используется GZipStream. Файлы, которые не подлежат сжатию после генерации нового файла вырастают в размере (mp3, bin, видео файлы). Текстовые файлы сжимаются лучше всего. 

## Тестовое задание

Требуется написать консольную программу на C# для генерации сигнатуры указанного файла. Сигнатура 
генерируется следующим образом: исходный файл делится на блоки равной (фиксированной) длины (если 
размер файла не кратен размеру блока, последний фрагмент может быть меньше или дополнен нулями до 
размера полного блока). Для каждого блока вычисляется значение hash функции и вместе с его номером 
выводится в консоль.

Интерфейс: командная строка, в которой указаны:
*  Путь до входного файла
*  Размер блока (по умолчанию, 1 Мб)

В случае успеха программа возвращает 0, при ошибке 1.

Обязательные требования:
*  Следует максимально оптимизировать скорость работы утилиты с учетом работы в многопроцессорной среде
*  Нужно реализовать правильную обработку ошибок на основе эксепшенов
*  При работе с потоками допускается использовать только стандартные классы и библиотеки из .Net 3.5 (исключая ThreadPool, BackgroundWorker).
*  Код программы должен следовать принципам ООП и ООД (читаемость, разбиение на классы и тд).
*  Алгоритм работы программы необходимо описать словами.
Дополнительным плюсом будет возможность корректной остановки программы по Ctrl-C.

Допущения:
*  Размер входного файла может быть много больше размера доступной физической памяти (> 4 Гб)
*  В качестве хэш функции можно использовать любую хэш функцию (MD5, CRC и т.д.)
Примечание: Просьба высылать проект целиком, а не только исходные коды.
